from collections import defaultdict
from typing import DefaultDict
import itertools
import yaml

with open('../../sslib/patches.yaml') as f:
    all_patches = yaml.safe_load(f)

globals = all_patches.pop("global")

FLOAT_KEYS = set(('posx', 'posy', 'posz', 'sizex', 'sizey', 'sizez'))

BAD_NAMES = {
    'story_flag1': 'storyflag1',
    'story_flag2': 'storyflag2',
    'angle': 'angley',
}

OBJ_SOBJ_MAP = {
    'OBJ': 'obj',
    'OBJS': 'obj',
    'STAG': 'sobj',
}

NORMAL_KEYS = set(('params1', 'params2', 'posx', 'posy', 'posz',  'sizex', 'sizey', 'sizez', 'anglex', 'angley', 'anglez', 'id'))
HEX_KEYS = set(('params1', 'params2', 'anglex', 'angley', 'anglez', 'id'))

oarc_add = defaultdict(set)
oarc_delete = defaultdict(set)

with open('src/patches_gen.rs','w') as f:
    f.write("""// DO NOT EDIT
// This file is autogenerated by gen_patches.py
use bzs::structs::*;
use std::collections::HashSet;
use crate::patches::{InvalidPatchError, ByIdExt, do_custom_obj_patch, do_custom_sobj_patch, zero_pad, find_highest_used_id};

pub fn base_stage_patches(
    stage: &str,
    room: Option<u8>,
    bzs: &mut BzsEntries,
    oarc_add: &mut HashSet<(u8, &'static str)>,
    oarc_delete: &mut HashSet<(u8, &'static str)>,
) -> Result<(), InvalidPatchError> {
    let mut highest_used_id = find_highest_used_id(bzs);
    match stage {
""")


    for stage, patches in all_patches.items():
        f.write(' ' * 8 + f'"{stage}" => \n')
        f.write(' ' * 8 + "match room {\n")
        by_room = defaultdict(list)
        for patch in patches:
            by_room[patch.get('room')].append(patch)
        for roomid, patches in by_room.items():
            if roomid is None:
                f.write(' ' * 12 + "None => {")
            else:
                f.write(' ' * 12 + f"Some({roomid}) => {{")
            patches_no_move = (p for p in patches if p['type'] != 'objmove')
            patches_move = (p for p in patches if p['type'] == 'objmove')
            for patch in itertools.chain(patches_no_move, patches_move):
                if 'name' in patch:
                    f.write(' ' * 12 + f"// {patch['name']}\n")
                if patch["type"] == "layeroverride":
                    f.write(' ' * 12 + "bzs.lyse = vec![")
                    for override in patch["override"]:
                        f.write(f"LYSE {{ layer: {override['layer']}, night: {override['night']}, storyflag: {override['story_flag']} }},")
                    f.write(' ' * 12 + "];\n")
                elif patch["type"] in ("objpatch", "objadd"):
                    if 'layer' in patch:
                        maybelayer = f".lay[{patch['layer']}]"
                    else:
                        maybelayer = ""
                    if patch["type"] == "objpatch":
                        if 'id' in patch:
                            find = f".modify_by_id(0x{patch['id']:X})?"
                        else:
                            find = f".get_mut({patch['index']}).unwrap()"
                        f.write(' ' * 12 + f"let obj = bzs{maybelayer}.{patch['objtype'].lower()}{find};\n")
                    else:
                        objtype = patch['objtype']
                        f.write(' ' * 12 + f"let mut mobj = {OBJ_SOBJ_MAP.get(objtype, objtype).upper()}::default();let obj = &mut mobj;\n")
                    for key, val in patch['object'].items():
                        if key in BAD_NAMES:
                            key = BAD_NAMES[key]
                        if key in FLOAT_KEYS:
                            f.write(' ' * 12 + f"obj.{key} = {val}f32;\n")
                        elif key == "name":
                            f.write(' ' * 12 + f"obj.{key} = zero_pad(b\"{val}\");\n")
                        elif patch['objtype'] in OBJ_SOBJ_MAP and not key in NORMAL_KEYS:
                            if val == -1:
                                val = "u32::MAX"
                            f.write(' ' * 12 + f"do_custom_{OBJ_SOBJ_MAP[patch['objtype']]}_patch(obj, \"{key}\", {val});\n")
                        else:
                            if key in HEX_KEYS:
                                val = f"0x{val:X}"
                            f.write(' ' * 12 + f"obj.{key} = {val};\n")
                    if patch["type"] == "objadd":
                        if 'id' in patch['object']:
                            f.write(' ' * 12 + "highest_used_id += 1;\n")
                            f.write(' ' * 12 + "obj.id = highest_used_id | (!0x3FF & obj.id);\n")
                        f.write(' ' * 12 + f"bzs{maybelayer}.{patch['objtype'].lower()}.push(mobj);\n")
                elif patch["type"] == "objdelete":
                    f.write(' ' * 12 + f"bzs.lay[{patch['layer']}].{patch['objtype'].lower()}.remove_by_id(0x{patch['id']:X})?;\n")
                elif patch["type"] == "objmove":
                    f.write(' ' * 12 + f"let mut moved_obj = bzs.lay[{patch['layer']}].{patch['objtype'].lower()}.remove_by_id(0x{patch['id']:X})?;\n")
                    f.write(' ' * 12 + "highest_used_id += 1;\n")
                    f.write(' ' * 12 + "moved_obj.id = highest_used_id | (!0x3FF & moved_obj.id);\n")
                    f.write(' ' * 12 + f"bzs.lay[{patch['destlayer']}].{patch['objtype'].lower()}.push(moved_obj);\n")
                elif patch["type"] == "objnadd":
                    f.write(' ' * 12 + f"bzs.lay[{patch['layer']}].objn.push(\"{patch['objn']}\".into());\n")
                elif patch["type"] == "oarcadd":
                    f.write(' ' * 12 + f'oarc_add.insert(({patch["destlayer"]}, "{patch["oarc"]}"));\n')
                    oarc_add[(stage, patch['destlayer'])].add(patch['oarc'])
                elif patch["type"] == "oarcdelete":
                    f.write(' ' * 12 + f'oarc_delete.insert(({patch["layer"]}, "{patch["oarc"]}"));\n')
                    oarc_delete[(stage, patch['layer'])].add(patch['oarc'])
                else:
                    print(f"unhandled: ", patch)
            
            f.write(' ' * 12 + "}")
        f.write(' ' * 12 + "_ => (),\n")
        f.write(' ' * 8 + "},\n")
    f.write("    _ => (),\n    }\n    Ok(())\n}\n\n")

    # write oarc_delete
    f.write("pub fn get_oarc_delete(stage: &str, layer: u8) -> &'static [&'static str] {\n")
    f.write("match (stage, layer) {\n")
    for ((stage, layer), oarcs) in sorted(oarc_delete.items()):
        f.write(f'("{stage}", {layer}) => &[\n')
        for oarc in sorted(oarcs):
            f.write(f'"{oarc}",\n')
        f.write('],\n')
    f.write("_ => &[],}\n")

    f.write("}\n\n")

    # write oarc_add
    f.write("pub fn get_oarc_add(stage: &str, layer: u8) -> &'static [&'static str] {\n")
    f.write("match (stage, layer) {\n")
    for ((stage, layer), oarcs) in sorted(oarc_add.items()):
        f.write(f'("{stage}", {layer}) => &[\n')
        for oarc in sorted(oarcs):
            f.write(f'"{oarc}",\n')
        f.write('],\n')
    f.write("_ => &[],}\n")

    f.write("}\n")
